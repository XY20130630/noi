\documentclass[a4paper]{article}
\usepackage{ctex}
\usepackage{xeCJK}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{colortbl}
\usepackage{fancyvrb}
\usepackage{longtable}
\usepackage{xcolor}
\usepackage[hidelinks]{hyperref}
\usepackage[affil-it]{authblk}
\usepackage[top = 1.0in, bottom = 1.0in, left = 1.0in, right = 1.0in]{geometry}
\usepackage{amsthm}

\setCJKfamilyfont{kai}{KaiTi_GB2312}
\newcommand{\kai}{\CJKfamily{kai}}

\setCJKfamilyfont{song}{SimSun}
\newcommand{\song}{\CJKfamily{song}}

\newcommand\spc{\vspace{6pt}}
\newcommand{\floor}[1]{\lfloor {#1} \rfloor}
\newcommand{\ceil}[1]{\lceil {#1} \rceil}
\newcommand*\chem[1]{\ensuremath{\mathrm{#1}}}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{problem}{例题}

% \kai

\date{\today}
%\date{\yestoday}
\title{$\rm NOI2013$ 解题报告}
\author{$\mathcal Pyh$}

\begin{document}

\maketitle

\kai

\section{向量内积}

考虑如何求出题目中的内积，我们把题目中给出的矩阵与它的转置矩阵乘起来，
然后问题就变成了判断除了对角线之外有没有$0$。

当$k=2$时，注意到如果不是$0$就是$1$，所以我们的问题就转化成了判断这两个矩阵相乘是
否等于一个全$1$的矩阵（对角线上的元素就是每个向量自己的内积，可以预处
理出来），于是可以在等式两边各自左乘一个随机01向量。

等式左边乘出来的复杂度是可以接受的，但是等式右边又需要$n^2$。但我们发
现等式右边基本全是$1$，于是可以预处理出随机的变量的和然后进行计算。

当$k=3$时，注意到$2\bmod -1\pmod{3}$，于是我们可以把求出来的每个结果进
行平方，然后判断是不是全$1$即可。

注意到这样就是$n\times d^2$的矩阵相乘，问题完美解决了。

\section{树的计数}

我们把所有点按照bfs序进行重标号，从小到大考虑每个点，于是我们就在逐层
遍历这棵树。

于是我们计算出每个点的深度比上一个点大$1$的概率，然后加起来就是答案
（期望线性性质）。

注意到，当当前点的dfs序小于上一个点的dfs序时，一定会深度加一。因为同一
层bfs序更大的点一定dfs序也更大。

那么这样子的深度加一是否一定对应方案呢，意思是说假设它的dfs序为$x$，上
一层一定可以找到一个dfs序为$x-1$的点吗？（它必须是当前这一层的开头，那
么一定是父亲的第一个儿子，dfs序一定为父亲的加$1$）

首先，bfs序小于它的点中一定有一个dfs序等于$x-1$的存在，因为不管前面的
决策如何，这一步都必须深度加一，那么因为保证有解，所以一定存在这么一个
dfs序为$x-1$的。

其次，这个点一定在上一层吗？这个倒不一定，但是在前面的决策中，一定会使
得接下来有解，所以我们只要在接下来的分析中，注意保证不会出现这种上一层
不存在的情况即可。

显然这一个深度加一的操作一定不会导致不合法的出现，因为这是必须的操作，
在前面的决策保证接下来的局面有合法解的前提下，一定不会导致不合法的情况
出现。

那么当当前点的dfs序大于上一个点的dfs序时会怎么样呢？

显然若深度要加一，那么至少得保证当前点的dfs序是上一个点的dfs序加一（因
为当前点的dfs序大于上一个点的dfs序，所以一定在上一个点的子树中，而当前
点肯定是上一个点的第一个儿子，所以一定得保证）。

如果当前点的dfs序大于上一个点的dfs序加一，那么就不得深度加一，与上面的
情况同理，这是规定动作，没有变化的可能，所以不会导致后续决策出现无解的情况。

现在的问题就变成了，如果当前点的dfs序等于上一个点的dfs序加一，那么有多
大概率能使深度加一。

如果在这里换层了，那么显然后面的点的dfs序都不得超过当前点的dfs序。并且
因为当前点一定是上一个点的第一个儿子，而上一个点是它们那一层的最后一个
点，所以接下来的点一定都在上一个点的子树中。那么dfs序一定在一个区间中，
所以我们查询接下来的点的dfs序是不是在一个区间中即可（即计算dfs序的最大
值与最小值）。

可以发现，如果满足上面两个条件，那么深度是否加一接下来都是有合法解的。

因为如果深度加一有合法解，那么我们可以把当前点和它的子树整体挪移到上一
个点的旁边，接在上一个点的父亲的下面，这样就对应着一种深度不加一的方案。

如果深度不加一有合法解，显然从当前点开始的接下来的点一定都会接在上一个
点的父亲的子树中，因为接下来的点的dfs序一定在一个区间中。所以我们可以
把当前点接到上一个点下面，剩下的点依次挪移下来，就对应了一个深度加一的
方案。

而这两种中一定有一个有合法解，那么就可以推出另外一个也有合法解。

那么概率是多少呢？我们注意到一个点能不能深度加一与之前的决策一点关系都
没有，所以如果深度能够加一也能够不加一，那么概率分别是$1/2$。

最后，如果当前点的dfs序等于上一个点的dfs序加一，但是不满足上面的两个条
件，那么显然就是规定操作，只能不加一了。

综上所述，首先判断当前点的dfs序是否小于上一个点的dfs序，如果是的话答案
加$1$。如果当前点的dfs序为上一个点的dfs序加一，并且满足上面那两个条件，
那么答案加$1/2$。

时间复杂度为$O(n)$。

\section{小Q的修炼}

提交答案题，未做。

\section{矩阵游戏}

使用十进制快速幂，推出一行的线性表示，然后得出两行之间第一个数的递推关
系，然后求出最后一行的第一个数，然后再求出最后一个数即可。

\section{书法家}

裸dp，代码量巨大。

\section{快餐店}

枚举哪条边断环，然后就变成求直径。所有情况取最小值。

那么先求出直径在子树中的情况，断环对它没有影响。

然后把环拆成两倍的序列，然后枚举断的边，然后线段树维护即可。

\end{document}
